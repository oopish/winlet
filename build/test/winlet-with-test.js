// Generated by CoffeeScript 1.9.2
(function(ªG) {
/*! Winlet 0.0.1 //// MIT Licence //// http://winlet.oopish.com/ */
var Node, SomeClass, Tudor, Winlet, tudor, xx, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªex, ªhas, ªinsert, ªis, ªisU, ªredefine, ªtype, ªuid,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ªC = 'Winlet';

ªV = '0.0.1';

Node = (function() {
  Node.prototype.C = 'Node';

  Node.prototype.toString = function() {
    return '[object Node]';
  };

  function Node(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/winlet/src/Node/Node-base.litcoffee Node()\n  ";
    this.childNodes = [];
    this.firstChild = null;
    this.lastChild = null;
    this.parentNode = null;
    this.previousSibling = null;
    this.nextSibling = null;
  }

  Node.prototype.appendChild = function(aChild) {
    var M, length, ref;
    M = "/winlet/src/Node/Node-base.litcoffee Node.appendChild()\n  ";
    if (!(aChild instanceof Node)) {
      throw TypeError(M + "`achild` does not inherit from `Node`");
    }
    if ((ref = aChild.parentNode) != null) {
      ref.removeChild(aChild);
    }
    aChild.parentNode = this;
    length = this.childNodes.push(aChild);
    this.firstChild = this.childNodes[0];
    this.lastChild = aChild;
    aChild.nextSibling = null;
    if (1 === length) {
      aChild.previousSibling = null;
    } else {
      aChild.previousSibling = this.childNodes[length - 2];
      aChild.previousSibling.nextSibling = aChild;
    }
    return aChild;
  };

  Node.prototype.insertBefore = function(newNode, referenceNode) {
    var M, i, ref;
    M = "/winlet/src/Node/Node-base.litcoffee Node.insertBefore()\n  ";
    if (!(newNode instanceof Node)) {
      throw TypeError(M + "`newNode` does not inherit from `Node`");
    }
    if (!(referenceNode instanceof Node)) {
      throw TypeError(M + "`referenceNode` does not inherit from `Node`");
    }
    i = this.childNodes.indexOf(referenceNode);
    if (-1 === i) {
      throw RangeError(M + "`referenceNode` not found in `childNodes`");
    }
    this.childNodes.splice(i, 0, newNode);
    this.firstChild = this.childNodes[0];
    this.lastChild = this.childNodes[length - 1];
    newNode.nextSibling = referenceNode;
    if (0 === i) {
      newNode.previousSibling = null;
    } else {
      newNode.previousSibling = referenceNode.previousSibling;
      referenceNode.previousSibling.nextSibling = newNode;
    }
    referenceNode.previousSibling = newNode;
    if ((ref = newNode.parentNode) != null) {
      ref.removeChild(newNode);
    }
    newNode.parentNode = this;
    return newNode;
  };

  Node.prototype.removeChild = function(child) {
    var M, i, ref, ref1;
    M = "/winlet/src/Node/Node-base.litcoffee Node.removeChild()\n  ";
    if (!(child instanceof Node)) {
      throw TypeError(M + "`child` does not inherit from `Node`");
    }
    i = this.childNodes.indexOf(child);
    if (-1 === i) {
      throw RangeError(M + "`child` not found in `childNodes`");
    }
    this.childNodes.splice(i, 1);
    this.firstChild = this.childNodes[0];
    this.lastChild = this.childNodes[length - 1];
    if ((ref = child.previousSibling) != null) {
      ref.nextSibling = child.nextSibling;
    }
    if ((ref1 = child.nextSibling) != null) {
      ref1.previousSibling = child.previousSibling;
    }
    child.parentNode = null;
    child.previousSibling = null;
    child.nextSibling = null;
    return child;
  };

  return Node;

})();

Node.HTMLDocument = (function(superClass) {
  extend(HTMLDocument, superClass);

  HTMLDocument.prototype.C = 'Node.HTMLDocument';

  HTMLDocument.prototype.toString = function() {
    return '[object Node.HTMLDocument]';
  };

  function HTMLDocument(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/winlet/src/Node/Node.HTMLDocument.litcoffee Node.HTMLDocument()\n  ";
    HTMLDocument.__super__.constructor.call(this);
    this.body = new Node.HTMLElement;
  }

  HTMLDocument.prototype.createElement = function(tagName) {
    return new Node.HTMLElement(tagName);
  };

  HTMLDocument.prototype.createTextNode = function(data) {
    return new Node.Text(data);
  };

  HTMLDocument.prototype.querySelector = function(selectors) {
    if ('body' === selectors) {
      return this.body;
    }
    return null;
  };

  HTMLDocument.prototype.querySelectorAll = function(selectors) {
    if ('body' === selectors) {
      return [this.body];
    }
    return [];
  };

  return HTMLDocument;

})(Node);

Node.HTMLElement = (function(superClass) {
  extend(HTMLElement, superClass);

  HTMLElement.prototype.C = 'Node.HTMLElement';

  HTMLElement.prototype.toString = function() {
    return '[object Node.HTMLElement]';
  };

  function HTMLElement(tagName1) {
    var M;
    this.tagName = tagName1;
    M = "/winlet/src/Node/Node.HTMLElement.litcoffee Node.HTML" + this.tagName + "Element()\n  ";
    HTMLElement.__super__.constructor.call(this);
    this.attributes = {};
  }

  HTMLElement.prototype.insertAdjacentHTML = function(position, text) {};

  HTMLElement.prototype.getAttribute = function(attributeName) {
    var value;
    value = this.attributes[attributeName];
    if (ªU === typeof value) {
      return null;
    } else {
      return value;
    }
  };

  HTMLElement.prototype.setAttribute = function(name, value) {
    this.attributes[name] = '' + value;
    return void 0;
  };

  return HTMLElement;

})(Node);

SomeClass = (function() {
  SomeClass.prototype.C = 'SomeClass';

  SomeClass.prototype.toString = function() {
    return '[object SomeClass]';
  };

  function SomeClass(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/winlet/src/SomeClass/SomeClass.litcoffee SomeClass()\n  ";
    this.x = null;
  }

  SomeClass.prototype.xx = function(xx) {
    var M;
    return M = "/winlet/src/SomeClass/SomeClass.litcoffee SomeClass.xx()\n  ";
  };

  return SomeClass;

})();

xx = function(xx) {
  var M;
  return M = "/winlet/src/SomeClass/SomeClass.litcoffee xx()\n  ";
};

Winlet = (function() {
  Winlet.prototype.C = 'Winlet';

  Winlet.prototype.toString = function() {
    return '[object Winlet]';
  };

  function Winlet(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/winlet/src/Winlet.litcoffee Winlet()\n  ";
    this.document = new Node.HTMLDocument;
  }

  Winlet.prototype.xx = function(xx) {
    var M;
    return M = "/winlet/src/Winlet.litcoffee Winlet.xx()\n  ";
  };

  return Winlet;

})();

xx = function(xx) {
  var M;
  return M = "/winlet/src/Winlet.litcoffee xx()\n  ";
};

ªA = 'array';

ªB = 'boolean';

ªE = 'error';

ªF = 'function';

ªN = 'number';

ªO = 'object';

ªR = 'regexp';

ªS = 'string';

ªU = 'undefined';

ªX = 'null';

ª = console.log.bind(console);

ªex = function(x, a, b) {
  var pos;
  if (-1 === (pos = a.indexOf(x))) {
    return x;
  } else {
    return b.charAt(pos);
  }
};

ªis = function(c, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (c) {
    return t;
  } else {
    return f;
  }
};

ªhas = function(h, n, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (-1 !== h.indexOf(n)) {
    return t;
  } else {
    return f;
  }
};

ªtype = function(x) {
  return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
};

ªisU = function(x) {
  return ªU === typeof x;
};

ªuid = function(p) {
  return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
};

ªinsert = function(basis, overlay, offset) {
  return basis.slice(0, offset) + overlay + basis.slice(offset + overlay.length);
};

ªredefine = function(obj, name, value, kind) {
  switch (kind) {
    case 'constant':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: true
      });
    case 'private':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: false
      });
  }
};

if (ªF === typeof define && define.amd) {
  define(function() {
    return Winlet;
  });
} else if (ªO === typeof module && module && module.exports) {
  module.exports = Winlet;
} else {
  ªG.Winlet = Winlet;
}

Tudor = (function() {
  Tudor.prototype.I = 'Tudor';

  Tudor.prototype.toString = function() {
    return "[object " + I + "]";
  };

  Tudor.prototype.articles = [];

  function Tudor(opt) {
    this.opt = opt != null ? opt : {};
    this["do"] = bind(this["do"], this);
    switch (this.opt.format) {
      case 'html':
        this.pageHead = function(summary) {
          return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
        };
        this.pageFoot = function(summary) {
          return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
        };
        this.articleHead = function(heading, fail) {
          return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
        };
        this.articleFoot = '</div></article>';
        this.sectionHead = function(heading, fail) {
          return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
        };
        this.sectionFoot = '</div></section>';
        this.jobFormat = function(heading, result) {
          return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
        };
        this.tick = '<b class="pass">\u2713</b> ';
        this.cross = '<b class="fail">\u2718</b> ';
        break;
      default:
        this.pageHead = function(summary) {
          return "" + summary;
        };
        this.pageFoot = function(summary) {
          return "\n" + summary;
        };
        this.articleHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
        };
        this.articleFoot = '';
        this.sectionHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
        };
        this.sectionFoot = '';
        this.jobFormat = function(heading, result) {
          return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
        };
        this.jobFoot = '';
        this.tick = '\u2713';
        this.cross = '\u2718';
    }
  }

  Tudor.prototype.add = function(lines) {
    var article, i, line, runner, section;
    article = {
      sections: []
    };
    runner = null;
    section = null;
    if (ªA !== ªtype(lines)) {
      throw new Error("`lines` isn’t an array");
    }
    if (0 === lines.length) {
      throw new Error("`lines` has no elements");
    }
    if (ªS !== ªtype(lines[0])) {
      throw new Error("`lines[0]` isn’t a string");
    }
    article.heading = lines.shift();
    i = 0;
    while (i < lines.length) {
      line = lines[i];
      switch (ªtype(line)) {
        case ªO:
          if (!line.runner) {
            throw new Error("Errant object");
          }
          runner = line.runner;
          break;
        case ªF:
          section.jobs.push(line);
          break;
        case ªS:
          if (this.isAssertion(lines[i + 1], lines[i + 2])) {
            if (!section) {
              throw new Error("Cannot add an assertion here");
            }
            section.jobs.push([runner, line, lines[++i], lines[++i]]);
          } else {
            section = {
              heading: line,
              jobs: []
            };
            article.sections.push(section);
          }
      }
      i++;
    }
    return this.articles.push(article);
  };

  Tudor.prototype["do"] = function() {
    var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, k, l, len, len1, len2, mock, mockFail, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
    pge = [];
    mock = null;
    pgePass = pgeFail = mockFail = 0;
    ref = this.articles;
    for (j = 0, len = ref.length; j < len; j++) {
      article = ref[j];
      art = [];
      artPass = artFail = 0;
      ref1 = article.sections;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        section = ref1[k];
        sec = [];
        secPass = secFail = 0;
        ref2 = section.jobs;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          job = ref2[l];
          switch (ªtype(job)) {
            case ªF:
              try {
                mock = job.apply(this, mock);
              } catch (_error) {
                e = _error;
                error = e.message;
              }
              if (error) {
                mockFail++;
                secFail++;
                sec.push(this.formatMockModifierError(job, error));
              }
              break;
            case ªA:
              runner = job[0], heading = job[1], expect = job[2], actual = job[3];
              result = runner(expect, actual, mock);
              if (!result) {
                sec.push(this.jobFormat("" + (this.sanitize(heading))));
                pgePass++;
                artPass++;
                secPass++;
              } else {
                sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                pgeFail++;
                artFail++;
                secFail++;
              }
          }
        }
        sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
        sec.push(this.sectionFoot);
        art = art.concat(sec);
      }
      art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
      art.push(this.articleFoot);
      pge = pge.concat(art);
      summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      if (mockFail) {
        summary = "\n" + this.cross + " (MOCK FAILS)";
      }
    }
    pge.unshift(this.pageHead(summary));
    pge.push(this.pageFoot(summary));
    return pge.join('\n');
  };

  Tudor.prototype.formatError = function(result) {
    switch (result.length + "-" + this.opt.format) {
      case '2-html':
        return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
      case '2-plain':
        return result[0] + "\n" + (this.sanitize(result[1].message));
      case '3-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
      case '3-plain':
        return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
      case '4-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
      case '4-plain':
        return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
      default:
        throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
    }
  };

  Tudor.prototype.formatMockModifierError = function(fn, error) {
    switch (this.opt.format) {
      case 'html':
        return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
      default:
        return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
    }
  };

  Tudor.prototype.reveal = function(value) {
    return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
      return '\u00b7' + (new Array(match.length)).join('\u00b7');
    }) : void 0;
  };

  Tudor.prototype.sanitize = function(value) {
    switch (this.opt.format) {
      case 'html':
        return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
      default:
        return value;
    }
  };

  Tudor.prototype["throw"] = {
    runner: function(expect, actual, mock) {
      var e, error;
      error = false;
      try {
        actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (!error) {
        return [
          'No exception thrown, expected', {
            message: expect
          }
        ];
      } else if (expect !== error.message) {
        return [error.message, 'was thrown, but expected', expect];
      }
    }
  };

  Tudor.prototype.equal = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== result) {
        if (result + '' === expect + '') {
          return [result, 'was returned, but expected', expect, true];
        } else {
          return [result, 'was returned, but expected', expect];
        }
      }
    }
  };

  Tudor.prototype.is = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== ªtype(result)) {
        return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
      }
    }
  };

  Tudor.prototype.match = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (ªF !== typeof expect.test) {
        return [
          '`test()` is not a function', {
            message: expect
          }
        ];
      } else if (!expect.test('' + result)) {
        return ['' + result, 'failed test', expect];
      }
    }
  };

  Tudor.prototype.isAssertion = function(line1, line2) {
    if (ªF !== ªtype(line2)) {
      return false;
    }
    if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
      return false;
    }
    return true;
  };

  return Tudor;

})();

tudor = new Tudor({
  format: ªO === typeof window ? 'html' : 'plain'
});

Winlet.runTest = tudor["do"];

tudor.add([
  "01 Winlet Constructor Usage", tudor.is, "The class and instance are expected types", "The Winlet class is a function", ªF, function() {
    return Winlet;
  }, "`new` returns an object", ªO, function() {
    return new Winlet;
  }
]);
}).call(this,this);
// Example vendor file. 
